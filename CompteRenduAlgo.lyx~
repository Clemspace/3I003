#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Compte Rendu 3I003 Confitures :))
\end_layout

\begin_layout Author
Rémi Dadvisard et Clément Castellon
\end_layout

\begin_layout Section
Partie Théorique
\end_layout

\begin_layout Subsection
Algorithme 1: Recherche Exhaustive
\end_layout

\begin_layout Paragraph
Question 1
\end_layout

\begin_layout Standard
Montrer par récurrence forte sur S la validité et la terminaison de cet
 algorithme lorsqu’il est appelé par l’appel initial RechercheExhaustive(k,
 V, S).
\end_layout

\begin_layout Description
Terminaison:
\end_layout

\begin_layout Standard
RechercheExhaustive(k, V, S) est une fonction récursive, et ne fait des
 appels que sur S, ou S-V[i].
\end_layout

\begin_layout Itemize
Sur S, si S<V[i], alors on cherche a comparer avec V[i-1](<V[i]), et on
 termine quand on atteint V[0].
\end_layout

\begin_layout Itemize
Sur S-V[i], si S-V[i] est négatif, alors l'algo termine.
 
\end_layout

\begin_layout Standard
L’algorithe se termine si s≤0, récursivement, la valeur de S est réduite
 de V[i] ≥0, à chaque appel, on a une boucle strictement décroissante, donc
 il existe un appel ou s sera négatif ou nul.
 ET donc si un appel récursif termine, tous les appels récursifs termineront.
 
\end_layout

\begin_layout Description
Validité:
\end_layout

\begin_layout Description
Validité: P(i) = « NbCont égal au nombre minimum pour remplir S=i » P(0)
 =0 donc valide P(1) = 1 Valide (V[1] = 1 étant obligatoire)
\end_layout

\begin_layout Description
x prends la plus petite valeur de RechercheExhaustive(k, V, S-V[k]) à RechercheE
xhaustive(k, V, S-V[1]).
 Qui sont valides par HR.
 Or, pour chacune de ses valeurs; il a besoin d’un seul bocal en plus, donc
 le nombre minimum sera égal a min(RechercheExhaustive(k, V, S-x) avec x
 appartenant à V) + 1.
 NBCont(i) renvoie ce nombre, donc: 
\end_layout

\begin_layout Description
RechercheExhaustive(k, V, S) est valide.
 
\end_layout

\begin_layout Description
Conclusion: donc l'algorithme est valide et se termine
\end_layout

\begin_layout Paragraph
Question 2
\end_layout

\begin_layout Standard
Supposons que les seuls bocaux disponibles sont des bocaux de capacités
 1dg et 2dg.
 On note a(s) le nombre d’appels récursifs effectués par RechercheExhaustive(2,
 [ 1, 2 ], s).
 
\end_layout

\begin_layout Standard
a)Exprimer a(s) sous forme d’une suite récursive.
\end_layout

\begin_layout Standard
\begin_inset Formula $a(s)$
\end_inset


\begin_inset Formula $=\begin{cases}
0 & si\:s=0\\
2 & si\:s=1\\
a(s-1)+a(s-2)+2 & si\:s\geq2
\end{cases}$
\end_inset

 .
\end_layout

\begin_layout Quote
Soit b(s) la suite définie par:
\end_layout

\begin_layout Verse
\begin_inset Formula $b\left(s\right)=\begin{cases}
0 & si\;s=0\\
2 & si\;s=1\\
2b(s-2)+2 & si\;s\geq2
\end{cases}$
\end_inset

 .
\end_layout

\begin_layout Quote
Soit c(s) la suite définie par:
\end_layout

\begin_layout Verse
\begin_inset Formula $c\left(s\right)=\begin{cases}
0 & si\;s=0\\
2c(s-1)+2 & si\;s\geq1
\end{cases}$
\end_inset

 .
\end_layout

\begin_layout Standard
\noindent
b)Montrer que pour tout entier 
\begin_inset Formula $s\geq0$
\end_inset

, on a 
\begin_inset Formula $b(s)\leq a(s)\leq c(s)$
\end_inset

.
\end_layout

\begin_layout Standard
La suite est strictement croissante et positive, on a donc 
\begin_inset Formula $a(s-1)+a(s-2)+2\geq a(s-1)$
\end_inset

 et 
\begin_inset Formula $a(s-1)\geq a(s-2)$
\end_inset

 on a donc 
\begin_inset Formula $a(s-1)+a(s-2)\leq2a(s-1)$
\end_inset

 et 
\begin_inset Formula $2a(s-2)\leq a(s-1)+a(s-2)$
\end_inset

 on a ainsi 
\begin_inset Formula $2a(s-2)+2\leq a(s-1)+a(s-2)+2\leq2(s-1)$
\end_inset

 or les suites a, b et c ont les mêmes premiers termes, on peut donc remplacer
 les termes de l'inégalité.
 on a ainsi 
\begin_inset Formula $b(s)\leq a(s)\leq c(s)$
\end_inset

pour tout entier 
\begin_inset Formula $s\geq0$
\end_inset


\end_layout

\begin_layout Standard
\noindent
c)Quel est le terme général de la suite c(s)? Justifiez.
\end_layout

\begin_layout Standard
Initialisation:
\end_layout

\begin_layout Standard
\begin_inset Formula $c_{0}=0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c_{1}=2$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c_{2}=6$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $c_{3}=14$
\end_inset


\end_layout

\begin_layout Standard
On décèle que 
\begin_inset Formula $c_{n}=2^{n+1}-2$
\end_inset


\end_layout

\begin_layout Standard
Supposons 
\begin_inset Formula $P_{n}=\:c_{n}=2^{n+1}-2$
\end_inset

 pour un n donné, montrons 
\begin_inset Formula $P_{n+1}$
\end_inset

: 
\begin_inset Formula $c_{n+1}=2^{n+2}-2$
\end_inset


\end_layout

\begin_layout Standard
Induction:
\end_layout

\begin_layout Standard
\begin_inset Formula $c_{n+1}=2c(n+1-1)+2$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c_{n+1}=2*(2^{n+1}-2)+2$
\end_inset

 Par H.R
\end_layout

\begin_layout Standard
\begin_inset Formula $c_{n+1}=2^{n+2}-4+2$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c_{n+1}=2^{n+2}-2$
\end_inset


\end_layout

\begin_layout Standard
Hérédité confirmée.
 
\emph on
On en déduit donc que 
\begin_inset Formula $c_{n}=2^{n+1}-2$
\end_inset

 pour tout 
\begin_inset Formula $n\geq0$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
d)En déduire que 
\begin_inset Formula $b(s)=c(\lceil\frac{s}{2}\rceil)$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Posons P:
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $b(k)=c(\lceil\frac{k}{2}\rceil)$
\end_inset

 avec 
\begin_inset Formula $k=\left\{ 0,...,n\right\} $
\end_inset


\begin_inset Quotes erd
\end_inset

 pour un n donné, montrons 
\begin_inset Formula $P_{n+1}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Induction:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(n+1)=2b(n-1)+2$
\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(n+1)=2c(\lceil\frac{n-1}{2}\rceil)+2$
\end_inset

 Par H.R
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(n+1)=2(2^{\lceil\frac{n-1}{2}\rceil+1}-2)+2$
\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(n+1)=2^{\lceil\frac{n-1}{2}\rceil+2}-2$
\end_inset

 or 
\begin_inset Formula $\lceil\frac{n-1}{2}\rceil+2=\lceil\frac{n+1}{2}\rceil+1$
\end_inset

par définition de la partie entière
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(s+1)=2^{\lceil\frac{n+1}{2}\rceil+1}-2$
\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $b(n+1)=c(\lceil\frac{n+1}{2}\rceil)$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Hérédité confirmée par le théorème de la recurrence forte.
\end_layout

\begin_layout Standard
\noindent
e)Donner le terme général de la suite b(s).
 En déduire un encadrement du nombre d'appels récursifs réalisés par RechercheEx
haustive(2, [1, 2], s).
 Que peut-on en conclure quant à la complexité temporelle de l'algorithme
 RechercheExhaustive?
\end_layout

\begin_layout Standard

\emph on
On déduit de la question précédente que 
\begin_inset Formula $b(s)=2^{\lceil\frac{n}{2}\rceil+1}-2$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
On peut ainsi encadre la complexité 
\begin_inset Formula $2^{\lceil\frac{n}{2}\rceil+1}-2\leq a(s)\leq2^{s+1}-2$
\end_inset


\end_layout

\begin_layout Standard

\emph on
On peut ainsi en déduire que RechercheExhaustive est minorée par 
\begin_inset Formula $2^{n/2}$
\end_inset

et surtout majorée 
\begin_inset Formula $2^{n}$
\end_inset

 par et donc de complexité 
\begin_inset Formula $\mathcal{\mathcal{O}}(2^{n})$
\end_inset

 
\end_layout

\begin_layout Subsection
Algorithme II : Programmation dynamique
\end_layout

\begin_layout Standard
Pour ce deuxième algorithme, nous allons exploiter la structure du problème
 pour éviter une exploration exhaustive de toutes les solutions.
 
\end_layout

\begin_layout Standard
On note m(S) le nombre minimum de bocaux pour S décigrammes de confiture
 et un tableau de capacités V.
 On définit une famille de problèmes intermédiaires de la façon suivante:
 étant donnés un entier s et un entier 
\begin_inset Formula $\forall i\in\left\{ 1,\ldots,k\right\} $
\end_inset

, on note m(s, i) le nombre minimum de bocaux nécessaires pour une quantité
 totale s en ne choisissant des bocaux que dans le système de capacités
 V [1], V [2] , .
 .
 .
 , V[i].
 
\end_layout

\begin_layout Standard
Pour initialiser la récursion, on pose: 
\end_layout

\begin_layout Description
- 
\begin_inset Formula $m(0,i)=0\qquad\forall i\in\left\{ 1,\ldots,k\right\} $
\end_inset

 : il est possible de réaliser la capacité totale 0 avec 0 bocal.
 
\end_layout

\begin_layout Description
- 
\begin_inset Formula $m(s,0)=+\infty\qquad\forall s\geq1$
\end_inset

 : il n’est pas possible de réaliser la capacité s ≥ 1 sans utiliser au
 moins un bocal.
 
\end_layout

\begin_layout Description
- 
\begin_inset Formula $m(s,i)=+\infty\qquad$
\end_inset

 
\begin_inset Formula $\forall i\in\left\{ 1,\ldots,k\right\} ,\:\;\forall s>0$
\end_inset

 : il n’est pas possible de réaliser une capacité négative.
\end_layout

\begin_layout Paragraph
Question 3
\end_layout

\begin_layout Standard
a)Quelle est la valeur de m(S) en fonction des valeurs m(s,i) définies dans
 la section précédente?
\end_layout

\begin_layout Standard
\begin_inset Formula $m(S)=m(S,k)$
\end_inset


\end_layout

\begin_layout Standard
b)Montrer la relation de récurrence suivante pour tout 
\begin_inset Formula $\boldsymbol{i\in\left\{ 1,\ldots,k\right\} }$
\end_inset


\begin_inset Formula 
\[
m(s,i)=\begin{cases}
0 & si\;s=0\\
\min\left\{ m(s,i-1),m(s-V[i],i)+1\right\}  & sinon
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\emph on
Initialisation:
\end_layout

\begin_layout Standard

\emph on
\begin_inset Formula $m(0,i)=0$
\end_inset

 voir énoncé.
\end_layout

\begin_layout Standard

\emph on
Supposons la relation de l'énoncé vraie pour les valeurs de m(s',i') avec
 
\begin_inset Formula $s'\epsilon\left\{ 0,\ldots,s-1\right\} $
\end_inset

et 
\begin_inset Formula $i'\epsilon\left\{ 0,\ldots,i\right\} $
\end_inset

 ainsi que la valeur 
\begin_inset Formula $m(s,i-1)$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
alors, soit m(s, i) utilise un bocal de la plus grande contenance et est
 égal à m(s-V[i],i)+1, soit il on ne l’utilise pas et m(s,i) = (s,i-1).
 
\end_layout

\begin_layout Standard

\emph on
or on veut minimiser la valeur de m(s,i) donc on a min(m(s,i-1),m(s-v[i],i)+1)
 si s≠0
\end_layout

\begin_layout Paragraph
Question 4
\end_layout

\begin_layout Standard
Pour résoudre le problème de manière plus efficace que l’algorithme RechercheExh
austive, on va utiliser l’approche dite de programmation dynamique .Le calcul
 des valeurs m(s, i), grâce à la relation de récurrence décrite dans la
 question précédente, nous permettra de trouver m(S).
\end_layout

\begin_layout Standard
L’idée maîtresse est de ne pas calculer une même valeur m(s, i) plusieurs
 fois: pour cela on stocke ces valeurs dans un tableau M doublement indicé.
 Dans chaque case du tableau M[s, i] (avec s ∈{ 0 , .
 .
 .
 , S } et i ∈{ 0 , .
 .
 .
 , k }), on stocke la valeur m(s,i), c’est-à-dire soit une valeur ∞ , soit
 le nombre de bocaux utilisés.
\end_layout

\begin_layout Standard
a)Décrire (et justifier) dans quel ordre les cases du tableau M peuvent
 être remplies en utilisant la formule de récurrence.
\end_layout

\begin_layout Standard

\emph on
On remplira le tableau à l'aide d'une boucle sur s d'abord, puis sur i à
 l'interieur de celle-ci: On remplit pour chaque s les i possibilités avant
 de passer à la valeur de s suivante
\end_layout

\begin_layout Standard
b)En déduire un algorithme AlgoProgDyn (en pseudo-code) qui détermine le
 nombre de bocaux nécessaires pour une quantité de confiture S.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AlgoProgDyn(S,V,k):
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Creer un tableau m(S,I)
\end_layout

\begin_layout Plain Layout
Pour tout s appartenant à {0,...,S}
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $m(s,0)=+\infty$
\end_inset


\end_layout

\begin_layout Plain Layout
fin pour
\end_layout

\begin_layout Plain Layout
Pour tout i appartenant à {0,...,k}
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $m(0,i)=0$
\end_inset


\end_layout

\begin_layout Plain Layout
fin pour
\end_layout

\begin_layout Plain Layout
pour tout s appartenant à {1,...S}:
\end_layout

\begin_layout Plain Layout
pour tout i appartenant à {1,...,k}:
\end_layout

\begin_layout Plain Layout
m(s,i)=min(m(s,i-1), m(s-V[i],i)+1}
\end_layout

\begin_layout Plain Layout
fin pour
\end_layout

\begin_layout Plain Layout
retourner m(s,i)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
c)Analyser la Complexité temporelle et spatiale de cet algorithme.
 On entend par Complexité spatiale l'espace mémoire requis en fonction de
 k et S.
\end_layout

\begin_layout Itemize
Complexité temporelle:
\end_layout

\begin_deeper
\begin_layout Itemize
L'algorithme effectue un parcours de chaque case du tableau en fonction
 des valeurs trouvées pour des s inférieurs, et termine lorsqu'il est à
 la case V[S][k].
 Il effectue donc un traitement pour chaque case, et il y a 
\begin_inset Formula $S\times k$
\end_inset

cases dans la matrice utilisée, donc cet algorithme a une Complexité de
 
\begin_inset Formula $\Theta(S\times k)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Complexité spatiale:
\end_layout

\begin_deeper
\begin_layout Itemize
L'algorithme va nécessiter un stockage d'un tableau de 
\begin_inset Formula $S\times k$
\end_inset

cases, donc il a une complexité spatiale de 
\begin_inset Formula $\Theta(S\times k)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Mise en œuvre
\end_layout

\end_body
\end_document
